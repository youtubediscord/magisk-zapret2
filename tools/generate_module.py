#!/usr/bin/env python3
"""
Generate Magisk module files from categories.txt and hostlists

Generates:
- strategies.sh - Shell script with all strategy options for nfqws2
- webroot/strategies.js - JavaScript file with strategy arrays for WebUI
"""

import os
import re
import shutil
from pathlib import Path

# Paths
SCRIPT_DIR = Path(__file__).parent
MODULE_DIR = SCRIPT_DIR.parent
ZAPRET_DIR = Path(r"H:\Privacy\zapret")

CATEGORIES_FILE = ZAPRET_DIR / "json" / "strategies" / "builtin" / "categories.txt"
LISTS_DIR = ZAPRET_DIR / "lists"
TCP_STRATEGIES_FILE = ZAPRET_DIR / "json" / "strategies" / "builtin" / "tcp.txt"
UDP_STRATEGIES_FILE = ZAPRET_DIR / "json" / "strategies" / "builtin" / "udp.txt"

OUTPUT_LISTS_DIR = MODULE_DIR / "zapret2" / "lists"
OUTPUT_WEBROOT = MODULE_DIR / "webroot"
OUTPUT_SCRIPTS = MODULE_DIR / "zapret2" / "scripts"


def parse_categories(filepath):
    """Parse categories.txt into list of category dicts"""
    categories = []
    current = None

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            # Section header [name]
            if line.startswith('[') and line.endswith(']'):
                if current:
                    categories.append(current)
                current = {'id': line[1:-1]}
                continue

            # Key = value
            if '=' in line and current:
                key, value = line.split('=', 1)
                current[key.strip()] = value.strip()

        if current:
            categories.append(current)

    return categories


def parse_strategies(filepath):
    """Parse tcp.txt or udp.txt into dict of strategies"""
    strategies = {}
    current_id = None
    current_name = None
    current_lines = []

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.rstrip()

            # Section [id]
            if line.startswith('[') and line.endswith(']'):
                if current_id and current_lines:
                    strategies[current_id] = {
                        'name': current_name or current_id,
                        'options': '\n'.join(current_lines)
                    }
                current_id = line[1:-1]
                current_name = None
                current_lines = []
                continue

            if current_id:
                if line.startswith('name = '):
                    current_name = line[7:].strip()
                elif line.startswith('--') or line.startswith('-'):
                    current_lines.append(line)

        if current_id and current_lines:
            strategies[current_id] = {
                'name': current_name or current_id,
                'options': '\n'.join(current_lines)
            }

    return strategies


def copy_hostlists():
    """Copy needed hostlists to module"""
    OUTPUT_LISTS_DIR.mkdir(parents=True, exist_ok=True)

    needed_files = [
        'youtube.txt', 'discord.txt', 'telegram.txt', 'whatsapp.txt',
        'facebook.txt', 'instagram.txt', 'twitter.txt', 'github.txt',
        'steam.txt', 'twitch.txt', 'soundcloud.txt', 'rutracker.txt',
        'rutor.txt', 'speedtest.txt', 'google.txt', 'amazon.txt',
        'roblox.txt', 'itch.txt', 'claude.txt', 'other.txt',
        'russia-blacklist.txt',
        # IPsets
        'ipset-youtube.txt', 'ipset-discord.txt', 'ipset-telegram.txt',
        'ipset-googlevideo.txt', 'ipset-whatsapp.txt', 'ipset-facebook.txt',
        'ipset-instagram.txt', 'ipset-twitter.txt', 'ipset-github.txt',
        'ipset-steam.txt', 'ipset-twitch.txt', 'ipset-soundcloud.txt',
        'ipset-rutracker.txt', 'ipset-amazon.txt', 'ipset-roblox.txt',
        'ipset-anydesk.txt', 'ipset-warp.txt', 'ipset-claude.txt',
        'ipset-censorliber.txt',
    ]

    copied = 0
    for fname in needed_files:
        src = LISTS_DIR / fname
        dst = OUTPUT_LISTS_DIR / fname
        if src.exists():
            shutil.copy2(src, dst)
            copied += 1
            print(f"  Copied: {fname}")
        else:
            print(f"  Missing: {fname}")

    return copied


def generate_strategies_sh(tcp_strats, udp_strats):
    """Generate strategies.sh with all strategies"""

    lines = [
        '#!/system/bin/sh',
        '##########################################################################################',
        '# Zapret2 Strategy Definitions',
        '# Auto-generated by generate_module.py',
        '##########################################################################################',
        '',
        'LISTS_DIR="$ZAPRET_DIR/lists"',
        '',
        '# Get strategy options by ID',
        'get_strategy_options() {',
        '    strategy_id="$1"',
        '    filter="$2"',
        '',
        '    case "$strategy_id" in',
    ]

    # TCP strategies
    lines.append('        # ==================== TCP STRATEGIES ====================')
    for sid, sdata in tcp_strats.items():
        opts = sdata['options'].replace('\n', ' \\\n')
        lines.append(f'        {sid})')
        lines.append(f'            echo "$filter \\')
        lines.append(f'{opts}"')
        lines.append('            ;;')
        lines.append('')

    # UDP strategies
    lines.append('        # ==================== UDP STRATEGIES ====================')
    for sid, sdata in udp_strats.items():
        opts = sdata['options'].replace('\n', ' \\\n')
        lines.append(f'        {sid})')
        lines.append(f'            echo "$filter \\')
        lines.append(f'{opts}"')
        lines.append('            ;;')
        lines.append('')

    lines.append('        *)')
    lines.append('            echo ""')
    lines.append('            ;;')
    lines.append('    esac')
    lines.append('}')

    return '\n'.join(lines)


def generate_strategies_js(tcp_strats, udp_strats):
    """Generate strategies.js with TCP and UDP strategy arrays for WebUI"""

    lines = [
        '// Auto-generated by generate_module.py',
        '// Do not edit manually - regenerate from tcp.txt and udp.txt',
        '',
        '// TCP Strategies (for HTTPS/TLS bypass)',
        'const TCP_STRATEGIES = ['
    ]

    # TCP strategies
    for sid, sdata in tcp_strats.items():
        name = sdata['name']
        # Escape quotes in name
        name = name.replace("'", "\\'")
        lines.append(f"  {{id: '{sid}', name: '{name}'}},")

    lines.append('];')
    lines.append('')
    lines.append('// UDP Strategies (for QUIC/Voice bypass)')
    lines.append('const UDP_STRATEGIES = [')

    # UDP strategies
    for sid, sdata in udp_strats.items():
        name = sdata['name']
        name = name.replace("'", "\\'")
        lines.append(f"  {{id: '{sid}', name: '{name}'}},")

    lines.append('];')
    lines.append('')

    # Add helper function to populate selects
    lines.append('''// Populate strategy selects on page load
function populateStrategies() {
  // TCP selects (all service categories)
  const tcpSelects = [
    'strat-youtube', 'strat-discord', 'strat-telegram-tcp', 'strat-whatsapp-tcp',
    'strat-facebook-tcp', 'strat-instagram-tcp', 'strat-twitter-tcp', 'strat-github-tcp',
    'strat-steam-tcp', 'strat-twitch-tcp', 'strat-soundcloud-tcp', 'strat-rutracker-tcp',
    'strat-other'
  ];

  tcpSelects.forEach(id => {
    const select = document.getElementById(id);
    if (select) {
      // Keep first option (Выключено)
      while (select.options.length > 1) select.remove(1);
      TCP_STRATEGIES.forEach(s => {
        select.add(new Option(s.name, s.id));
      });
    }
  });

  // UDP selects (QUIC/Voice)
  const udpSelects = ['strat-youtube-udp', 'strat-discord-voice-udp', 'strat-udp-discord'];

  udpSelects.forEach(id => {
    const select = document.getElementById(id);
    if (select) {
      while (select.options.length > 1) select.remove(1);
      UDP_STRATEGIES.forEach(s => {
        select.add(new Option(s.name, s.id));
      });
    }
  });
}

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { TCP_STRATEGIES, UDP_STRATEGIES, populateStrategies };
}''')

    return '\n'.join(lines)


def generate_start_script(categories):
    """Generate category handling code for zapret-start.sh"""

    lines = []
    for cat in categories:
        cat_id = cat['id']
        var_name = f'STRATEGY_{cat_id.upper()}'
        base_filter = cat.get('base_filter_hostlist') or cat.get('base_filter_ipset') or cat.get('base_filter', '')
        strat_type = cat.get('strategy_type', 'tcp')

        lines.append(f'''
    # {cat.get('full_name', cat_id)}
    if [ -n "${var_name}" ] && [ "${var_name}" != "none" ]; then
        filter="{base_filter}"
        strat_opts=$(get_strategy_options "${var_name}" "$filter")
        if [ -n "$strat_opts" ]; then
            if [ $first -eq 0 ]; then
                OPTS="$OPTS --new"
            fi
            OPTS="$OPTS $strat_opts"
            first=0
            log_msg "Added {cat.get('full_name', cat_id)}: ${var_name}"
        fi
    fi''')

    return '\n'.join(lines)


def main():
    print("=" * 60)
    print("Zapret2 Magisk Module Generator")
    print("=" * 60)

    # Parse categories
    print("\n[1] Parsing categories.txt...")
    categories = parse_categories(CATEGORIES_FILE)
    print(f"    Found {len(categories)} categories")

    # Parse strategies
    print("\n[2] Parsing strategies...")
    tcp_strats = parse_strategies(TCP_STRATEGIES_FILE)
    udp_strats = parse_strategies(UDP_STRATEGIES_FILE)
    print(f"    TCP: {len(tcp_strats)}, UDP: {len(udp_strats)}")

    # Copy hostlists
    print("\n[3] Copying hostlists...")
    copied = copy_hostlists()
    print(f"    Copied {copied} files")

    # Generate strategies.sh (for shell scripts)
    print("\n[4] Generating strategies.sh...")
    strats_sh = generate_strategies_sh(tcp_strats, udp_strats)
    strats_path = MODULE_DIR / "zapret2" / "strategies.sh"
    with open(strats_path, 'w', encoding='utf-8', newline='\n') as f:
        f.write(strats_sh)
    print(f"    Written to {strats_path}")

    # Generate strategies.js (for WebUI)
    print("\n[5] Generating webroot/strategies.js...")
    OUTPUT_WEBROOT.mkdir(parents=True, exist_ok=True)
    strats_js = generate_strategies_js(tcp_strats, udp_strats)
    strats_js_path = OUTPUT_WEBROOT / "strategies.js"
    with open(strats_js_path, 'w', encoding='utf-8', newline='\n') as f:
        f.write(strats_js)
    print(f"    Written to {strats_js_path}")
    print(f"    TCP strategies: {len(tcp_strats)}")
    print(f"    UDP strategies: {len(udp_strats)}")

    # Define main categories for start script
    main_cats = [
        'youtube', 'youtube_udp', 'discord', 'discord_voice_udp',
        'telegram_tcp', 'whatsapp_tcp', 'facebook_tcp', 'instagram_tcp',
        'twitter_tcp', 'github_tcp', 'steam_tcp', 'twitch_tcp',
        'other'
    ]

    # Generate start script additions
    print("\n[6] Generating start script code...")
    start_code = generate_start_script([c for c in categories if c['id'] in main_cats])

    # Save generated code for manual review
    gen_dir = MODULE_DIR / "tools" / "generated"
    gen_dir.mkdir(exist_ok=True)

    with open(gen_dir / "start_script_code.txt", 'w', encoding='utf-8') as f:
        f.write(start_code)

    print(f"\n    Generated code saved to {gen_dir}")

    print("\n" + "=" * 60)
    print("DONE!")
    print(f"  - strategies.sh: {strats_path}")
    print(f"  - strategies.js: {strats_js_path}")
    print("=" * 60)
    print("\nNOTE: index.html now loads strategies dynamically from strategies.js")
    print("      Make sure index.html includes: <script src=\"strategies.js\"></script>")
    print("      And calls populateStrategies() after DOM load")


if __name__ == '__main__':
    main()
